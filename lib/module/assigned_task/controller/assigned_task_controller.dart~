import 'package:roomrounds/core/apis/api_function.dart';
import 'package:roomrounds/core/apis/models/tickets/ticket_model.dart';
import 'package:roomrounds/core/apis/models/tickets/ticket_status_model.dart';
import 'package:roomrounds/core/apis/models/tickets/tickets_list_model.dart';
import 'package:roomrounds/core/constants/imports.dart';
import 'package:roomrounds/module/create_ticket/controller/create_ticket_controller.dart';

import '../../../core/apis/models/employee/employee_model.dart';

class AssignedTaskController extends GetxController {
  List<Ticket> _openTickets = [];
  int _openPage = 1;
  final int _pageSize = 10;
  bool _hasMoreOpenTickets = true;
  bool isFetchingOpenTickets = false;

  List<Ticket> _closedTickets = [];
  int _closedPage = 1;
  bool hasMoreClosedTickets = true;
  bool isFetchingClosedTickets = false;

  bool hasOpenTickets = false;
  bool hasClosedTickets = false;
  bool isAssignedToMe = true;
  int? totalTicketsCount;
  int? urgentTicketsCount;
  String? selectedStatusValue;
  DateTime? startDate;
  DateTime? endDate;

  void _updateHasOpenTickets(bool value) {
    hasOpenTickets = value;
    update();
  }

  void _updateHasClosedTickets(bool value) {
    hasClosedTickets = value;
    update();
  }

  List<TicketStatusModel> get ticketStatusList => [
        TicketStatusModel(lookupId: null, value: "All"),
        TicketStatusModel(lookupId: null, value: "Open"),
        ...?_ticketStatusList,
      ];
  List<TicketStatusModel>? _ticketStatusList;

  final List<String> _ticketsTypesList = [AppStrings.assignedMe];

  List<String> get ticketsTypesList => _ticketsTypesList;
  int? statusId;
  TicketsType _ticketsType = TicketsType.assignedMe;

  TicketsType get ticketsType => _ticketsType;

  TextEditingController replyController = TextEditingController();

  List<Ticket> get openTickets => _openTickets;

  List<Ticket> get closedTickets => _closedTickets;

  @override
  void onInit() {
    super.onInit();
    fetchTicketStatusList();
    _addTicketsTypes();

    startDate = DateTime.now().subtract(Duration(days: 7));
    endDate = DateTime.now();

    _initialLoadTickets();
  }

  Future<void> _initialLoadTickets() async {
    await Future.wait([
      loadOpenTickets(initial: true),
      if (profileController.isManager) _loadClosedTickets(initial: true),
    ]);
  }

  Future<List<Ticket>> _fetchTicketsFromServer({
    required bool isClosed,
    required int page,
  }) async {
    final data = {
      "isAssignedMe": _ticketsType == TicketsType.assignedMe,
      "pageNo": page,
      "size": _pageSize,
      "startDate": startDate?.toIso8601String(),
      "endDate": endDate?.toIso8601String(),
      "isPagination": true,
    };

    if (isClosed) {
      if (profileController.isManager) {
        data["assignBy"] = profileController.userId;
      }
    }

    if (selectedStatusValue != null && selectedStatusValue != "All") {
      final selectedStatus = _ticketStatusList?.firstWhere(
            (status) => status.value == selectedStatusValue,
        orElse: () => TicketStatusModel(lookupId: null, value: "All"),
      );
      if (selectedStatus != null && selectedStatus.lookupId != null) {
        data["statusId"] = selectedStatus.lookupId;
      }
    }

    final resp = await APIFunction.call(
      APIMethods.post,
      Urls.getAllTickets,
      dataMap: data,
      fromJson: TicketsListModel.fromJson,
      showLoader: false,
      showErrorMessage: false,
      isGoBack: false,
    );

    if (resp != null && resp is TicketsListModel) {
      totalTicketsCount = resp.totalTicketCount;
      urgentTicketsCount = resp.urgentTicketCount;
      return resp.tickets ?? [];
    }

    return [];
  }

  Future<void> loadOpenTickets(
      {bool initial = false, bool refresh = false}) async {
    if (initial) {
      if (isClosed) {
        _updateHasClosedTickets(false);
      } else {
        _updateHasOpenTickets(false);
      }
      isFetchingOpenTickets = true;
      _openPage = 1;
      List<Ticket> fetched =
          await _fetchTicketsFromServer(isClosed: false, page: _openPage);
      _openTickets = fetched;
      _hasMoreOpenTickets = fetched.length == _pageSize;
      isFetchingOpenTickets = false;
      if (isClosed) {
        _updateHasClosedTickets(true);
      } else {
        _updateHasOpenTickets(true);
      }
      update();
    } else if (refresh) {
      List<Ticket> fetched =
          await _fetchTicketsFromServer(isClosed: false, page: 1);
      if (fetched.isNotEmpty) {
        if (_openTickets.isEmpty ||
            fetched.first.ticketId != _openTickets.first.ticketId) {
          List<Ticket> newTickets = [];
          for (var ticket in fetched) {
            if (!_openTickets.any((t) => t.ticketId == ticket.ticketId)) {
              newTickets.add(ticket);
            }
          }
          if (newTickets.isNotEmpty) {
            _openTickets.insertAll(0, newTickets);
            update();
          }
        }
      }
    }
  }

  Future<void> fetchMoreOpenTickets() async {
    if (!_hasMoreOpenTickets || isFetchingOpenTickets) return;
    isFetchingOpenTickets = true;
    _openPage++;
    List<Ticket> fetched =
        await _fetchTicketsFromServer(isClosed: false, page: _openPage);
    if (fetched.isNotEmpty) {
      _openTickets.addAll(fetched);
    }
    if (fetched.length < _pageSize) {
      _hasMoreOpenTickets = false;
    }
    isFetchingOpenTickets = false;
    update();
  }

  Future<void> _loadClosedTickets(
      {bool initial = false, bool refresh = false}) async {
    if (initial) {
      if (isClosed) {
        _updateHasClosedTickets(false);
      } else {
        _updateHasOpenTickets(false);
      }
      isFetchingClosedTickets = true;
      _closedPage = 1;
      List<Ticket> fetched =
          await _fetchTicketsFromServer(isClosed: true, page: _closedPage);
      _closedTickets = fetched;
      hasMoreClosedTickets = fetched.length == _pageSize;
      isFetchingClosedTickets = false;
      if (isClosed) {
        _updateHasClosedTickets(true);
      } else {
        _updateHasOpenTickets(true);
      }
      update();
    } else if (refresh) {
      List<Ticket> fetched =
          await _fetchTicketsFromServer(isClosed: true, page: 1);
      if (fetched.isNotEmpty) {
        if (_closedTickets.isEmpty ||
            fetched.first.ticketId != _closedTickets.first.ticketId) {
          List<Ticket> newTickets = [];
          for (var ticket in fetched) {
            if (!_closedTickets.any((t) => t.ticketId == ticket.ticketId)) {
              newTickets.add(ticket);
            }
          }
          if (newTickets.isNotEmpty) {
            _closedTickets.insertAll(0, newTickets);
            update();
          }
        }
      }
    }
  }

  Future<void> fetchMoreClosedTickets() async {
    if (!hasMoreClosedTickets || isFetchingClosedTickets) return;
    isFetchingClosedTickets = true;
    _closedPage++;
    List<Ticket> fetched =
        await _fetchTicketsFromServer(isClosed: true, page: _closedPage);
    if (fetched.isNotEmpty) {
      _closedTickets.addAll(fetched);
    }
    if (fetched.length < _pageSize) {
      hasMoreClosedTickets = false;
    }
    isFetchingClosedTickets = false;
    update();
  }

  void refreshTickets() {
    loadOpenTickets(refresh: true);
    if (profileController.isManager) {
      _loadClosedTickets(refresh: true);
    }
  }

  void updateDateFilters({required DateTime start, required DateTime end}) {
    startDate = start;
    endDate = end;
    loadOpenTickets(initial: true);
    if (profileController.isManager) {
      _loadClosedTickets(initial: true);
    }
    update();
  }

  void _addTicketsTypes() {
    bool isManager = profileController.isManager;
    if (isManager) {
      _ticketsTypesList.add(AppStrings.assignedTo);
    } else {
      _ticketsTypesList.add(AppStrings.sendTo);
    }
  }

  void refreshOpenAndClosedTickets() {
    loadOpenTickets(refresh: true);
    if (profileController.isManager) {
      _loadClosedTickets(refresh: true);
    }
  }

  Employee? selectedEmployee;

  void setSelectedEmployee(Employee employee) {
    selectedEmployee = employee;
    update();
  }

  CreateTicketController createTicketController =
      Get.put(CreateTicketController());

  void _closeTicketApi({
    int? ticketId,
    String? reply,
    int? statusId,
    bool? isClosed,
  }) async {
    if (ticketId != null) {
      String params =
          '?ticketId=$ticketId&reply=$reply&statusId=$statusId&isClosed=$isClosed';
      if (selectedEmployee?.userId != null) {
        params += '&assignTo=${selectedEmployee!.userId}';
      }
      var resp = await APIFunction.call(
        APIMethods.post,
        Urls.updateTicketStatus + params,
        showLoader: true,
        showErrorMessage: true,
        showSuccessMessage: true,
        isGoBack: false,
      );

      if (resp != null && resp is bool && resp == true) {
        refreshOpenAndClosedTickets();
        selectedEmployee = null;
        update();
      }
    }
  }

  void changeClosedCompletedType(String? value) {
    _loadClosedTickets(initial: true);
  }

  void changeTicketsType(String? value) {
    if (value != null && value.trim().isNotEmpty) {
      if (value == AppStrings.assignedMe) {
        _ticketsType = TicketsType.assignedMe;
      } else if (value == AppStrings.assignedTo) {
        _ticketsType = TicketsType.assignedTo;
      } else if (value == AppStrings.sendTo) {
        _ticketsType = TicketsType.sendTo;
      } else {
        _ticketsType = TicketsType.assignedMe;
      }
      loadOpenTickets(initial: true);
      if (_ticketsType == TicketsType.assignedMe ||
          _ticketsType == TicketsType.assignedTo) {
        if (profileController.isManager) {
          _loadClosedTickets(initial: true);
        }
      }
    }
  }

  void changeStatusFilter(String? value) {
    selectedStatusValue = value;
    loadOpenTickets(initial: true);
    if (profileController.isManager) {
      _loadClosedTickets(initial: true);
    }
    update();
  }

  Future<List<TicketStatusModel>> fetchTicketStatusList() async {
    if (_ticketStatusList != null && _ticketStatusList!.isNotEmpty) {
      return _ticketStatusList!;
    }
    Map<String, dynamic> data = {"type": "TicketDependenciesStatus"};
    var resp = await APIFunction.call(
      APIMethods.post,
      Urls.ticketStatus,
      dataMap: data,
      showLoader: false,
      showErrorMessage: true,
      isGoBack: false,
    );

    if (resp != null && resp is List) {
      _ticketStatusList =
          resp.map((item) => TicketStatusModel.fromJson(item)).toList();
      return _ticketStatusList!;
    }
    return [];
  }

  void onTicketTap({
    Ticket? ticket,
    TicketsType? type,
    bool isClosed = false,
    bool isManager = false,
  }) {
    _openTicketsDialog(
      type: TicketDialogs.closeTicket,
      ticket: ticket,
    );
  }

  void _openTicketsDialog({TicketDialogs? type, Ticket? ticket}) async {
    List<TicketStatusModel> statusList = await fetchTicketStatusList();
    List<String> statusStrings =
        statusList.map((status) => status.value ?? '').toList();

    customLogger("Ticket: ${ticket?.toJson()}");
    _showFullWidthDialog(
      CloseTicketDialouge(
        ticket: ticket,
        showClose: false,
        sendStatusList: statusStrings,
        textController: replyController,
        onReplyButtonTap: () {
          _closeTicketApi(
            ticketId: ticket?.ticketId,
            reply: replyController.text,
            statusId: statusId,
            isClosed: true,
          );
        },
        onRadioTap: (index) {
          statusId = statusList[index].lookupId;
        },
      ),
    );
  }

  void _showFullWidthDialog(Widget child) {
    Get.dialog(
      Dialog(
        insetPadding: const EdgeInsets.symmetric(horizontal: 14),
        child: child,
      ),
    );
  }
}
